import torch
from torch import nn

adv_criterion = nn.MSELoss()
recon_criterion = nn.L1Loss()

def get_gen_adversarial_loss(real_X, disc_Y, gen_XY, adv_criterion):
    """
        Computes the generator loss based on adversarial criteria.

        Parameters:
        - real_X: Tensor, representing the real data.
        - disc_Y: Discriminator model that evaluates the input data.
        - gen_XY: Generator model to convert real_X to fake_Y.
        - adv_criterion: Adversarial loss criterion used for training the generator.

        Returns:
        - adversarial_loss: The adversarial loss for the generator, which measures how
          well the generator is able to fool the discriminator.
        - fake_Y: The fake data generated by the generator based on real_X.
    """
    fake_Y = gen_XY(real_X)
    disc_fake_Y_hat = disc_Y(fake_Y)
    adversarial_loss = adv_criterion(disc_fake_Y_hat, torch.ones_like(disc_fake_Y_hat))
    return adversarial_loss, fake_Y

def get_identity_loss(real_X, gen_YX, identity_criterion):
    """
        Computes the identity loss for the generator.

        Parameters:
        - real_X: Tensor, representing the real input data.
        - gen_YX: Generator model that maps data from domain Y back to domain X.
        - identity_criterion: Loss criterion used for computing the identity loss.

        Returns:
        - identity_loss: The identity loss for the generator, which measures how well the generator
          is able to reproduce the real_X without much alteration.
        - identity_X: The data generated by the generator that should ideally be identical to real_X.
    """
    identity_X = gen_YX(real_X)
    identity_loss = identity_criterion(identity_X, real_X)
    return identity_loss, identity_X

def get_cycle_consistency_loss(real_X, fake_Y, gen_YX, cycle_criterion):
    """
        Computes the cycle consistency loss for the generator.

        Parameters:
        - real_X: Tensor, representing the original input data.
        - fake_Y: Tensor, the generated data from the original data using another generator.
        - gen_YX: Generator model that maps data from domain Y back to domain X.
        - cycle_criterion: Loss criterion used for computing the cycle consistency loss.

        Returns:
        - cycle_loss: The cycle consistency loss, which measures how well the generator
          can map the generated data back to the original data.
        - cycle_X: The data generated by `gen_YX` when applied to `fake_Y`, which should ideally be identical to `real_X`.
    """
    cycle_X = gen_YX(fake_Y)
    cycle_loss = cycle_criterion(cycle_X, real_X)
    return cycle_loss, cycle_X

def get_gen_loss(real_A, real_B, gen_AB, gen_BA, disc_A, disc_B, adv_criterion, identity_criterion, cycle_criterion, lambda_identity=0.1, lambda_cycle=10):
    """
        Computes the total generator loss for a CycleGAN model, comprising adversarial, identity, and cycle consistency losses.

        Parameters:
        - real_A: Tensor, real samples from domain A.
        - real_B: Tensor, real samples from domain B.
        - gen_AB: Generator model that maps samples from domain A to B.
        - gen_BA: Generator model that maps samples from domain B to A.
        - disc_A: Discriminator model for domain A.
        - disc_B: Discriminator model for domain B.
        - adv_criterion: Loss criterion used for the adversarial loss.
        - identity_criterion: Loss criterion for identity loss.
        - cycle_criterion: Loss criterion for cycle consistency loss.
        - lambda_identity: Weight for the identity loss term in the total loss.
        - lambda_cycle: Weight for the cycle consistency loss term in the total loss.

        Returns:
        - gen_loss: Total generator loss as a weighted sum of adversarial, identity, and cycle consistency losses.
        - fake_A: Generated samples from domain B back to domain A.
        - fake_B: Generated samples from domain A to domain B.
    """
    adv_loss_BA, fake_A = get_gen_adversarial_loss(real_B, disc_A, gen_BA, adv_criterion)
    adv_loss_AB, fake_B = get_gen_adversarial_loss(real_A, disc_B, gen_AB, adv_criterion)
    gen_adversarial_loss = adv_loss_BA + adv_loss_AB

    identity_loss_A, identity_A = get_identity_loss(real_A, gen_BA, identity_criterion)
    identity_loss_B, identity_B = get_identity_loss(real_B, gen_AB, identity_criterion)
    gen_identity_loss = identity_loss_A + identity_loss_B

    cycle_loss_BA, cycle_A = get_cycle_consistency_loss(real_A, fake_B, gen_BA, cycle_criterion)
    cycle_loss_AB, cycle_B = get_cycle_consistency_loss(real_B, fake_A, gen_AB, cycle_criterion)
    gen_cycle_loss = cycle_loss_BA + cycle_loss_AB

    gen_loss = lambda_identity * gen_identity_loss + lambda_cycle * gen_cycle_loss + gen_adversarial_loss
    return gen_loss, fake_A, fake_B

